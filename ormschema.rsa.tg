TGraph 2;

Schema ormschema.ORMSchema;

GraphClass ORMGraph {importDate: String, xmlId: String, importedFileName: String, schemaName: String};

Package structure;
EnumDomain FactKind (FACT, IMPLIEDFACT, SUBTYPEFACT);
EnumDomain ConceptualDataTypeKinds (AUTOCOUNTERNUMERICDATATYPE, AUTOTIMESTAMPTEMPORALDATATYPE, DATEANDTIMETEMPORALDATATYPE, DATETEMPORALDATATYPE, DECIMALNUMERICDATATYPE, DOUBLEPRECISIONFLOATINGPOINTNUMERICDATATYPE, FIXEDLENGTHRAWDATADATATYPE, FIXEDLENGTHTEXTDATATYPE, LARGELENGTHRAWDATADATATYPE, LARGELENGTHTEXTDATATYPE, MONEYNUMERICDATATYPE, OBJECTIDOTHERDATATYPE, OLEOBJECTRAWDATADATATYPE, PICTURERAWDATADATATYPE, ROWIDOTHERDATATYPE, SIGNEDINTEGERNUMERICDATATYPE, SIGNEDLARGEINTEGERNUMERICDATATYPE, SIGNEDSMALLINTEGERNUMERICDATATYPE, SINGLEPRECISIONFLOATINGPOINTNUMERICDATATYPE, TIMETEMPORALDATATYPE, TRUEORFALSELOGICALDATATYPE, UNSIGNEDINTEGERNUMERICDATATYPE, UNSIGNEDLARGEINTEGERNUMERICDATATYPE, UNSIGNEDSMALLINTEGERNUMERICDATATYPE, UNSIGNEDTINYINTEGERNUMERICDATATYPE, VARIABLELENGTHRAWDATADATATYPE, VARIABLELENGTHTEXTDATATYPE, YESORNOLOGICALDATATYPE);
abstract VertexClass RoleKind {xmlId: String, multiplicityLowerBound: Integer, multiplicityUpperBound: Integer, isMandatory: Boolean, name: String};
VertexClass RoleProxy: RoleKind;
VertexClass ConceptualDataType {dataType: ConceptualDataTypeKinds, length: Integer, scale: Integer};
abstract VertexClass EntityObject: ObjectType {referenceMode: String};
VertexClass EntityType: EntityObject;
VertexClass Fact {name: String, factKind: FactKind, readingOrder: String, representsComposition: Boolean = "f", xmlId: String};
VertexClass ObjectifiedType: EntityObject;
abstract VertexClass ObjectType {name: String, xmlId: String, isIndependent: Boolean};
VertexClass Range {maxValue: Integer, minValue: Integer};
VertexClass Role: RoleKind;
VertexClass RoleSequence;
Comment structure.ValueRange "ValueRange&nbsp;models&nbsp;a&nbsp;range&nbsp;of&nbsp;values.&nbsp;The&nbsp;lower&nbsp;and&nbsp;upper&nbsp;bounds&nbsp;of&nbsp;this&nbsp;range&nbsp;are&nbsp;parsed&nbsp;as&nbsp;Strings&nbsp;because&nbsp;the&nbsp;data&nbsp;type&nbsp;of&nbsp;these&nbsp;values&nbsp;is&nbsp;determined&nbsp;by&nbsp;the&nbsp;ConceptualDataType&nbsp;of&nbsp;the&nbsp;ValueType&nbsp;which&nbsp;has&nbsp;this&nbsp;ValueConstraint&nbsp;or&nbsp;the&nbsp;ConceptualDataType&nbsp;of&nbsp;the&nbsp;ValueType&nbsp;used&nbsp;to&nbsp;identify&nbsp;the&nbsp;player&nbsp;of&nbsp;the&nbsp;Role&nbsp;which&nbsp;has&nbsp;this&nbsp;ValueConstraint.";
VertexClass ValueRange {invariantMaxValue: String, minValue: String, invariantMinValue: String, maxValue: String, maxInclusion: Boolean, minInclusion: Boolean};
VertexClass ValueType: ObjectType {isImplicitBooleanValue: Boolean};
EdgeClass HasDatatype from ValueType (1,*) to ConceptualDataType (1,1) role conceptualDataType;
EdgeClass ValueTypeHasValueConstraint from ValueType (0,1) role valueConstrainedValueType to constraints.ValueConstraint (0,1) role valueTypeValueConstraint;
EdgeClass ConsistsOfRoles from RoleSequence (0,*) role roleSequenceContainer to Role (1,*) role role aggregation shared;
EdgeClass RoleHasValueConstraint from Role (0,1) role valueConstrainedRole to constraints.ValueConstraint (0,1) role roleValueConstraint;
EdgeClass RoleHasCardinalityConstraint from Role (0,1) role cardinalityConstrainedRole to constraints.CardinalityConstraint (0,1) role roleCardinalityConstraint;
EdgeClass SpecializesObject from ObjectType (0,*) role supertype to ObjectType (0,*) role subtype;
EdgeClass Plays from ObjectType (1,1) role player to Role (0,*) role playedRole;
EdgeClass IsImpliedBy from Fact (1,1) role fact to ObjectifiedType (0,1) role objectifiedType;
EdgeClass ContainsRole from Fact (1,1) role fact to RoleKind (1,*) role factRole aggregation composite;
EdgeClass EntityObjectHasCardinalityConstraint from ObjectType (0,1) role cardinalityConstrainedObjectType to constraints.CardinalityConstraint (0,1) role objectTypeCardinalityConstraint;
EdgeClass HasPreferredIdentifierRole from EntityObject (0,*) role identifiedEntityObject to Role (0,*) role preferredIdentifierRole;
EdgeClass HasPreferredIdentifier from ValueType (0,*) role preferredIdentifierValueType to EntityObject (0,*) role identifiedEntityObject;
Comment structure.IncludesConstaint "Only&nbsp;add&nbsp;Constraints&nbsp;to&nbsp;Facts&nbsp;that&nbsp;apply&nbsp;to&nbsp;roles.&nbsp;Those&nbsp;that&nbsp;apply&nbsp;to&nbsp;ObjectType&nbsp;(ValueConstraint&nbsp;on&nbsp;ValueType&nbsp;and&nbsp;CardinalityConstraint&nbsp;on&nbsp;EntityObjects)&nbsp;aren't&nbsp;associated&nbsp;with&nbsp;a&nbsp;specific&nbsp;Fact";
EdgeClass IncludesConstaint from Fact (0,*) to constraints.Constraint (1,*) role constraint;
EdgeClass LinksToLinkedRole from RoleProxy (0,1) role roleProxy to Role (0,1) role linkedRole;
EdgeClass HasJoinRule from RoleSequence (1,1) to derivations.JoinRule (0,1) role joinRule;
EdgeClass Implies from Fact (0,1) to Fact (0,*) role impliedFact aggregation composite;
Package constraints;
EnumDomain RingConstraintKind (ACYCLIC, ANTISYMMETRIC, ASYMMETRIC, INTRANSITIVE, IRREFLEXIVE, PURELYREFLEXIVE, REFLEXIVE, STRONGLYINTRANSITIVE, SYMMETRIC, TRANSITIVE);
EnumDomain ValueComparisonKind (EQUAL, GREATER, GREATEREQUAL, LESS, LESSEQUAL, NOTEQUAL);
EnumDomain SetComparisonConstraintKind (EXCLUSIVEOR, INCLUSIVEOR, EXCLUSION, EQUALITY, SUBSET);
VertexClass CardinalityConstraint: Constraint {isRoleConstraint: Boolean};
VertexClass FrequencyConstraint: RoleSequenceConstraint;
VertexClass MandatoryConstraint: RoleSequenceConstraint {isImplied: Boolean};
VertexClass RingConstraint: RoleSequenceConstraint {type: RingConstraintKind};
abstract VertexClass RoleSequenceConstraint: Constraint;
Comment constraints.SetComparisonConstraint "If&nbsp;SetComparisonKind&nbsp;==&nbsp;SUBSET:\nthe&nbsp;RoleSequences&nbsp;within&nbsp;the&nbsp;SubsetConstraint&nbsp;element&nbsp;in&nbsp;the&nbsp;ORM&nbsp;schema&nbsp;are&nbsp;ordered.&nbsp;The&nbsp;first&nbsp;RoleSequence&nbsp;contains&nbsp;the&nbsp;subset&nbsp;and&nbsp;the&nbsp;second&nbsp;RoleSequence&nbsp;contains&nbsp;the&nbsp;superset&nbsp;roles.";
VertexClass SetComparisonConstraint: RoleSequenceConstraint {type: SetComparisonConstraintKind};
VertexClass UniquenessConstraint: RoleSequenceConstraint;
Comment constraints.ValueComparisonConstraint "This&nbsp;kind&nbsp;of&nbsp;constraint&nbsp;presents&nbsp;itself&nbsp;with&nbsp;a&nbsp;single&nbsp;\"orm:RoleSequence\"&nbsp;in&nbsp;the&nbsp;ORM&nbsp;schema&nbsp;file.&nbsp;In&nbsp;the&nbsp;case&nbsp;of&nbsp;directed&nbsp;operation&nbsp;it&nbsp;is&nbsp;important&nbsp;to&nbsp;note&nbsp;the&nbsp;sequence&nbsp;of&nbsp;the&nbsp;two&nbsp;roles:&nbsp;the&nbsp;first&nbsp;role&nbsp;is&nbsp;the&nbsp;source&nbsp;of&nbsp;the&nbsp;directed&nbsp;relation;&nbsp;the&nbsp;second&nbsp;role&nbsp;is&nbsp;the&nbsp;target&nbsp;of&nbsp;the&nbsp;directed&nbsp;relation.";
VertexClass ValueComparisonConstraint: RoleSequenceConstraint {operator: ValueComparisonKind};
VertexClass ValueConstraint: Constraint {isRoleConstraint: Boolean};
abstract VertexClass Constraint {isInterpredicateConstraint: Boolean, xmlId: String};
EdgeClass ConsistsOfValueRanges from ValueConstraint (1,*) to structure.ValueRange (1,*) role valueRange aggregation shared;
EdgeClass ContainsRoleSequence from RoleSequenceConstraint (1,1) role associatedConstraint to structure.RoleSequence (1,*) role roleSequence aggregation composite;
EdgeClass HasFrequencyRange from FrequencyConstraint (0,*) role constraint to structure.Range (1,1) role frequencyRange;
EdgeClass HasCardinalityRange from CardinalityConstraint (0,*) to structure.Range (1,*) role cardinalityRange aggregation shared;
Package derivations;
EnumDomain CombinationKind (AND, INCLUSIVEOR, EXCLUSIVEOR, NONE);
EnumDomain PathedRoleKind (POSTINNERJOIN, SAMEFACTTYPE);
VertexClass ConstraintRoleProjection {xmlId: String};
VertexClass JoinPath {xmlId: String};
VertexClass JoinPathProjection {xmlId: String};
VertexClass JoinRule;
VertexClass PathedRole {type: PathedRoleKind, xmlId: String};
VertexClass RolePath {operator: CombinationKind, xmlId: String};
VertexClass SubPath {xmlId: String};
EdgeClass HasRootObjectType from RolePath (0,*) role rolePath to structure.ObjectType (1,1) role rootObjectType;
EdgeClass ContainsSubPath from RolePath (1,1) role rolePathContainingSubPath to SubPath (0,*) role subPath aggregation composite;
EdgeClass LinksToReferencedRole from PathedRole (0,1) to structure.Role (1,1) role referencedRole;
EdgeClass HasJoinPath from JoinRule (1,1) to JoinPath (1,*) role joinPath aggregation composite;
EdgeClass ContainsConstraintRoleProjections from JoinPathProjection (1,1) to ConstraintRoleProjection (1,*) role constraintRoleProjection aggregation composite;
EdgeClass RefersToRolePath from JoinPathProjection (1,1) to RolePath (1,1) role referencedRolePath;
EdgeClass ContainsJoinPathProjection from JoinPath (1,1) to JoinPathProjection (1,*) role joinPathProjection aggregation composite;
EdgeClass ContainsRolePath from JoinPath (1,1) role containingJoinPath to RolePath (1,*) role containedRolePath aggregation composite;
EdgeClass ProjectedFromPathedRole from ConstraintRoleProjection (1,1) to PathedRole (0,1) role projectionSourcePathedRole;
EdgeClass HasPathedRole from SubPath (1,1) role subPathContainer to PathedRole (1,*) role subPathPathedRole aggregation composite;
EdgeClass ContainsPathedRole from RolePath (1,1) role rolePath to PathedRole (0,*) role pathedRole aggregation composite;
EdgeClass ProjectsOnto from ConstraintRoleProjection (0,*) to structure.Role (0,1) role projectionTarget;
EdgeClass ProjectedFromObjectType from ConstraintRoleProjection (0,*) to structure.ObjectType (0,1) role projectionSourceObjectType;

